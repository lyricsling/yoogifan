+++
date = '2025-04-21T14:40:22+08:00'
draft = true
title = 'Bugtrak'
+++
trac工具

极限编程（Extreme Programming），要求在编写代码前编写单元测试。或编码前设计测试。
自己为自己写测试可能带来的问题：下意识的回避问题
gcov或者lcov + genhtml

## 单元测试过程
1. 定义测试的粒度
编写单元测试需要时间。但从长远来看，忽略单元测试，可能会引火烧身。bug越晚发现，代价越高。
将单元测试作为实际实现的一部分。
修复bug，并对已有代码进行重新评估，修复单元测试用例。
由简到繁。

2. 构思单个测试
考虑一下问题：
- 编写的这段代码有什么作用？（有什么作用）
- 采用什么方式调用每个方法？（怎么使用）
- 调用者，可能破坏方法的哪些前置条件？（故意不按条件使用方法）
- 哪些方式误用方法？
- 预计将哪些类数据作为输入？
- 预计不将哪些类数据作为输入？（作用是什么呢）
- 边缘情景

3. 创建示例数据和结果
最常见的错误就是，将测试与代码行为进行匹配。
在运行测试前，就要确定测试的正确输出。

4. 编写测试
- 每次测试只测一点，如果测试失败，将指向特定的功能片段。
- 测试中要力求具体。明确指出测试失败的原因。
- 测试代码中广泛使用日志记录。
- 测试需要使用其他子系统，考虑子系统的存根或mock。
- 互相审查测试代码。

5. 运行测试
连续集成构建后，自动运行所有单元测试；测试失败时，发送电子邮件通知开发人员。
设置本地开发环境，每次编译代码执行单元测试。


gtest的使用

## 高级测试
各个组件协同工作。

### 集成测试
涉及两个或更多类。

## 测试的建议
1. 花时间设计自动化测试系统；
2. 压力测试；
3. 多系统测试；
4. 注入错误测试，如网络中断等情形；
5. 回归测试，验证bug的修复，可以附加bug编号；

# 调试
调试技巧

调试的基本定律和bug分类；

错误日志，
调试跟踪，
断言，
崩溃转储，

## 调试的基本定律
第一原则是对自己诚实，承认程序一定会包含bug。

## 分类
灾难性bug，程序死亡，数据损坏，操作系统故障。软件之外：医疗软件，导致人体接受过量辐射。
非灾难性bug，结果不正确。
cosmetic bug，结果都正确，但不如预期那么好。

## 避免bug
请同事审查代码。
测试，测试，再测试。
编写自动单元测试。
预计错误条件，并恰当处理他们。
智能指针避免内存泄漏。
不要忽略编译警告。
使用静态代码分析工具。
使用良好的编码风格。高可读性和简洁性。

## 为 bug 做好规划
### 错误日志记录
- 不可恢复的错误，无法分配内存或系统调用意外失败。
- 获取到了意料之外的值。

### 调试跟踪
通过参数确定是否启用调试模式。
通过宏定义调试模式，不会增加发行版本的大小。

环形缓冲区
只记录近期的日志记录。数据写入内存中，一块固定大小的缓冲区来保存，缓冲区填满时，重新在缓冲区开头处写入数据。

## 调试技术
### 重现bug
- 正确的环境中重复触发bug
- 查找与bug相关的代码，以指导如何重现问题
- 运行自动化测试，如模拟运行24小时。
- 不同硬件并发运行测试
- 压力测试，寻找bug

### 调试可重现的bug
1.记录调试消息，通过打开调试模式查看日志信息
2.使用调试器

### 调试不可重现的bug
1. 猜测问题出现的可能性，并进行尝试，知道能重复复现
2. 查看日志分析，可能找到问题原因
3. 如果崩溃，查看转储文件
4. 检查代码
5. 使用内存观察工具
6. 添加额外日志记录

无法确定是否真正修复问题

## 调试退化
从没有问题的版本一步一步的向后查找

## 调试内存问题

### 内存错误分类


#### 内存释放的错误
1. 内存泄漏
```cpp
void memoryLeak()
{
	int *p = new int[1000];
	return ;
}
```
2. 使用不匹配的分配和释放操作,通常不会引起程序崩溃，造成内存损坏，在一段时间后崩溃。
```cpp
void mismatchedFree()
{
	int *p1 = (int*)malloc(sizeof(int));
	delete p1; //Bug
	
	int *p2 = new int;
	delete []p2; //Bug
	
	int *p3 = new int[100];
	free p3; //Bug
}
```
3. 多次释放内存
```cpp
void doubleFree()
{
	int *p1 = new int[1000];
	delete[] p1;
	int *p2 = new int[100];
	delete[] p2; // delete twice
}
```
4. 释放未分配的内存
```cpp
void freeUnallocated()
{
	int *p = reinterpret_cast<int *>(10000);
	delete p;
}
```

5. 释放堆栈内存
```cpp
void freeStack()
{
	int x;
	int *p = &x;
	delete p;
}

```

内存访问错误
1. 无效内存访问
```cpp
void accessInvalid()
{
	int *p = nullptr;
	*p = 5;
}
```

2. 访问已经释放的值，可能导致异常出现奇怪的现象
```cpp
void accessFreed()
{
	int* p1 = new int;
	delete p1;
	int *p2 = new int;
	*p1 = 5;
}
```



